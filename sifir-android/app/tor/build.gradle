plugins {
    id 'com.android.library'
}

android {
    compileSdkVersion 30
    buildToolsVersion "30.0.1"

    defaultConfig {
        minSdkVersion 28
        targetSdkVersion 30
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        consumerProguardFiles "consumer-rules.pro"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    sourceSets{
        main{
            jniLibs.srcDirs = ['src/main/jniLibs',"$buildDir/native-libs"]
        }
        test{
            jniLibs.srcDirs = ['src/test/jniLibs',"$buildDir/native-libs"]
        }
    }

}

// app/build.gradle
//def rustBasePath = ".."
//def archTriplets = [
////        'armeabi-v7a': 'armv7-linux-androideabi',
////        'arm64-v8a': 'aarch64-linux-android',
//        "x86":"i686-linux-android",
//        "armeabi": "armv7-linux-androideabi",
//        "arm64":"aarch64-linux-android"
//]
//
//// TODO: only pass --release if buildType is release
//archTriplets.each { arch, target ->
////    // execute cargo metadata and get path to target directory
////    tasks.create(name: "cargo-output-dir-${arch}", description: "Get cargo metadata") {
////        new ByteArrayOutputStream().withStream { os ->
////            exec {
////                commandLine 'cargo', 'metadata', '--format-version', '1'
////                workingDir rustBasePath
////                standardOutput = os
////            }
////            def outputAsString = os.toString()
////            def json = new groovy.json.JsonSlurper().parseText(outputAsString)
////
////            logger.info("cargo target directory: ${json.target_directory}")
////            project.ext.cargo_target_directory = json.target_directory
////        }
////    }
////    // Build with cargo
////    tasks.create(name: "cargo-build-${arch}", type: Exec, description: "Building core for ${arch}", dependsOn: "cargo-output-dir-${arch}") {
////        workingDir rustBasePath
////        commandLine 'cargo', 'build', "--target=${target}", '--release'
////    }
//    // Sync shared native dependencies
//    tasks.create(name: "sync-rust-deps-${arch}", type: Sync, dependsOn: "cargo-build-${arch}") {
//        from "${rustBasePath}/src/libs/${arch}"
//        include "*.so"
//        into "src/main/libs/${arch}"
//    }
//    // Copy build libs into this app's libs directory
//    tasks.create(name: "rust-deploy-${arch}", type: Copy, dependsOn: "sync-rust-deps-${arch}", description: "Copy rust libs for (${arch}) to jniLibs") {
//        from "${project.ext.cargo_target_directory}/${target}/release"
//        include "*.so"
//        into "src/main/libs/${arch}"
//    }
//
//    // Hook up tasks to execute before building java
//    tasks.withType(JavaCompile) {
//        compileTask -> compileTask.dependsOn "rust-deploy-${arch}"
//    }
//    preBuild.dependsOn "rust-deploy-${arch}"
//
//    // Hook up clean tasks
//    tasks.create(name: "clean-${arch}", type: Delete, description: "Deleting built libs for ${arch}", dependsOn: "cargo-output-dir-${arch}") {
//        delete fileTree("${project.ext.cargo_target_directory}/${target}/release") {
//            include '*.so'
//        }
//    }
//    clean.dependsOn "clean-${arch}"
//}

dependencies {

    implementation 'androidx.appcompat:appcompat:1.1.0'
    implementation 'com.google.android.material:material:1.1.0'
//    implementation 'com.android.support:support-annotations:28.0.0'
    testImplementation 'junit:junit:4.+'
    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
}